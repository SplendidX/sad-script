// SAD-Script Prelude
// Copyright (c) 2015, Brian Luft.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
// following conditions are met:
//
// - Redistributions of source code must retain the above copyright notice, this list of conditions and the following
// disclaimer.
// - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
// following disclaimer in the documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
// USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Intrinsics /////////////////////////////////////////////////////////////////////////////////////////////////////////

import function type-of (x)
import function hash (x)
import function to-string (x)
import function print (x)
import function get-type (code) // 0=Nil, 1=Int, 2=Double, 3=Bool, 4=String, 5=List, 6=Function, 7=Error, 8=Type

// algebraic operators
import function + (a b)
import function - (a b)
import function * (a b)
import function / (a b)
import function % (a b)

// bitwise operators
import function bitwise-and (a b)
import function bitwise-or (a b)
import function bitwise-xor (a b)

// trigonometric functions
import function sin (x)
import function cos (x)
import function tan (x)
import function asin (x)
import function acos (x)
import function atan (x)
import function atan2 (y x)

// hyperbolic functions
import function sinh (x)
import function cosh (x)
import function tanh (x)

// exponential and logarithmic functions
import function exp (x)
import function log (x)
import function log10 (x)

// power operators and functions
import function ** (a b)
import function sqrt (x)

// rounding functions
import function ceil (x)
import function floor (x)

// boolean operators (no short circuiting)
import function and (a b)
import function or (a b)
import function not (x)

// comparison operators
import function = (a b)
import function < (a b)
import function <= (a b)
import function > (a b)
import function >= (a b)
import function << (a b)
import function >> (a b)

// list functions
import function list.length (self) 
import function list.get-at (self index) 
import function list.set-at! (self index value) 
import function list.insert-at! (self index value) 
import function list.remove-at! (self index) 

// string functions
import function string.length (self) 
import function string.get-at (self index) 

// error functions
import function error (message)
import function error.message (self)

// Constants //////////////////////////////////////////////////////////////////////////////////////////////////////////

var Nil = (get-type 0)
var Int = (get-type 1)
var Double = (get-type 2)
var Bool = (get-type 3)
var String = (get-type 4)
var List = (get-type 5)
var Function = (get-type 6)
var Error = (get-type 7)
var Type = (get-type 8)
var Any = (get-type 9)

// Basics /////////////////////////////////////////////////////////////////////////////////////////////////////////////

function list xs = xs
function nil? (self) = [self = Nil]
function nil-or-error? (self) = [[self = Nil] or [self = Error]]
function non-nil? (self) = (not (nil? self))
function error? (self) = [self = Error]
function zero? (self) = [self = 0]
function true? (self) = [self = true]
function false? (self) = [self = false]
function printv (x) = (print (to-string x))
function != (a b) = (not [a = b])

function die! (x) { // allow die to be used in an expression
   die x
}

function println (x) {
   (printv x)
   (print "\n")
}

function list.append! (self value) {
   var index = (list.length self)
   [self list.insert-at! index value]
}

function += (collection item) = [collection list.append! item]

function @ (self index) = match {
   case String Int: [self string.get-at index]
   case List Int: [self list.get-at index]
   default: (die! "Expected (String Int) or (List Int).")
}

function @= (self index value) = [collection list.set-at! index value]

function length (self) = match {
   case String: [self string.length]
   case List: [self list.length]
   default: (die! "Expected String or List.")
}

function pipe pipeline {
   var pipeline-length = (list.length pipeline)

   if (zero? pipeline-length) {
      return nil
   }

   var value = [pipeline @ 0]
   for i from 1 to [pipeline-length - 1] {
      var step = [pipeline @ i]
      set value = (step value)
   }
   return value
}

// Streams ////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A stream is like IEnumerable.
// The stream is a function.  You call the stream and it returns an iterator.
// The iterator is a function.  You call the iterator repeatedly and it returns a value, or nil to signal the end.

function to-stream (x) = match {
   case List: (list.to-stream x)
   case Function: x
   default: (error "Invalid type.")
}

function list.to-stream (lst) = \() {
   var i = 0
   var n = (list.length lst)
   return \() {
      if [i < n] {
         var item = [lst @ i]
         set i = [i + 1]
         return item
      } else {
         return nil
      }
   }
}

function to-list (xs) {
   switch {
      case List: {
         return xs
      }
      case Function: {
         var lst = (list)
         for x in xs {
            [lst += x]
         }
         return lst
      }
      default: {
         die "Expected a list or stream."
      }
   }
}

function ... (low high) = \() {
   var n = low
   return \() {
      if [n > high] {
         return nil
      } else {
         var old-n = n
         set n = [n + 1]
         return old-n
      }
   }
}

function reverse (xs) {
   var xs-list = [xs to-list]
   return \() {
      var i = [[xs-list list.length] - 1]
      return \() {
         if [i < 0] {
            return nil
         } else {
            var old-i = i
            set i = [i - 1]
            return [xs-list @ old-i]
         }
      }
   }
}

function skip (n xs) {
   var stream = (to-stream xs)
   return \() {
      var iterator = (stream)
      for i from 1 to n {
         (iterator)
      }
      return iterator
   }
}

function take (n xs) {
   var stream = (to-stream xs)
   return \() {
      var iterator = (stream)
      var num-so-far = 0
      return \() {
         if [num-so-far < n] {
            set num-so-far = [num-so-far + 1]
            return (iterator)
         } else {
            return nil
         }
      }
   }
}

function where (predicate xs) {
   var stream = (to-stream xs)
   return \() {
      var iterator = (stream)
      return \() {
         while true {
            var value = (iterator)
            if (nil-or-error? value) {
               return value
            } elseif (predicate value) {
               return value
            }
         }
      }
   }
}

function select (selector xs) {
   var stream = (to-stream xs)
   return \() {
      var iterator = (stream)
      return \() {
         var value = (iterator)
         return match value {
            case Nil: nil
            case Error: value
            default: (selector value)
         }
      }
   }
}

function reduce (reducer xs) {
   var stream = (to-stream xs)
   var iterator = (stream)
   var value = (iterator)
   if (nil-or-error? value) {
      return value
   }
   while true {
      var new-value = (iterator)
      switch new-value {
         case Error: {
            return new-value
         }
         case Nil: {
            return value
         }
         default: {
            set value = (reducer value new-value)
         }
      }
   }
}

function first (xs) {
   switch {
      case String: {
         return [xs @ 0]
      }
      case List: {
         return [xs @ 0]
      }
      case Function: {
         var iterator = (xs)
         return (iterator)
      }
      default: {
         return (argument-type-error "xs")
      }
   }
}

function any? (xs) = (nil? (first xs))
function empty? (xs) = (non-nil? (first xs))

// hashtable //////////////////////////////////////////////////////////////////////////////////////////////////////////
// A list of buckets, where the index into the list equals [hash % number-of-buckets]
// Each bucket is a list of pairs.
// Each pair is a two-element list: (list key value)

var HASHTABLE-BUCKET-COUNT = 37

function hashtable () {
   var x = (list)
   for i from 1 to HASHTABLE-BUCKET-COUNT {
      [x += nil]
   }
   return x
}

// returns nil if the key does not exist in the hashtable.
function hashtable.get (self key) {
   var bucket-index = [(hash key) % HASHTABLE-BUCKET-COUNT]
   var bucket = [self @ bucket-index]
   if [bucket nil?] {
      return nil
   } else {
      for pair in bucket {
         var pair-key = [pair @ 0]
         if [pair-key = key] {
            return [pair @ 1]
         }
      }
      return nil
   }
}

// returns true if a value was overwritten, false if not.
function hashtable.set! (self key value) {
   var new-pair = (list key value)
   var bucket-index = [(hash key) % HASHTABLE-BUCKET-COUNT]
   var bucket = [self @ bucket-index]
   if [bucket nil?] {
      set bucket = (list new-pair)
      [self @= bucket-index bucket]
   } else {
      // If the key already exists then overwrite it.
      for pair at i in bucket {
         if [[pair @ 0] = key] {
            [bucket @= i new-pair]
            return true
         }
      }
      [bucket += new-pair]
   }
   return false
}

function hashtable.remove! (self key) {
   var bucket-index = [(hash key) % HASHTABLE-BUCKET-COUNT]
   var bucket = [self @ bucket-index]
   if (not [bucket nil?]) {
      for pair at i in bucket {
         if [[pair @ 0] = key] {
            [bucket list.remove-at! i]
            return true
         }
      }
   }
   return false
}

// hashset ////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A dict where all the values are ignored (but happen to be set to true)

function hashset () {
   return (dict)
}

function hashset-add (self key) {
   return [self dict.set! key true]
}

function hashset-has? (self key) {
   return (true? [self dict.get key])
}

function hashset-remove (self key) {
   [self dict.remove! key]
}

// chain //////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A doubly-linked list: (list head-node count)
// Each node: (list value prev next)

function chain () {
   return (list nil 0)
}
var chain.HEAD = 0 // chain-node or nil
var chain.COUNT = 1 // int

function chain-node (value prev next) {
   return (list value prev next)
}
var chain-node.VALUE = 0 // any
var chain-node.PREV = 1 // chain-node or nil
var chain-node.NEXT = 2 // chain-node or nil

function chain.push! (self value) {
   var old-head = [self @ chain.HEAD]
   var new-head = (chain-node value nil old-head)
   [self @= chain.HEAD new-head]
   if (non-nil? old-head) {
      [old-head @= chain-node.PREV new-head]
   }
   [self @= chain.COUNT [[self @ chain.COUNT] + 1]]
}

function chain.pop! (self) {
   var old-head = [self @ chain.HEAD]
   if (nil? old-head) {
      return nil
   } else {
      var new-head = [head @ chain-node.NEXT]
      [self @= chain.HEAD new-head]
      if (non-nil? new-head) {
         [new-head @= chain-node.PREV nil]
      }
      [self @= chain.COUNT [[self @ chain.COUNT] - 1]]
      return [old-head @ chain-node.VALUE]
   }
}

function chain.remove! (self node) {
   var prev = [node @ chain-node.PREV]
   var next = [node @ chain-node.NEXT]
   if (nil? prev) { // this is the head node
      [self @= chain.HEAD next]
   } else { // this is a middle or tail node
      [prev @= chain.NEXT node]
   }
   if (non-nil? next) {
      [next @= chain.PREV prev]
   }
   [self @= chain.COUNT [[self @ chain.COUNT] - 1]]
}
